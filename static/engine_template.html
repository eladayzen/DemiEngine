<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Playable Ad</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
    canvas { display: block; position: absolute; }
  </style>
</head>
<body>

<!--
  BUILD NOTES (M6 pipeline will handle these before shipping):
  - Replace the two CDN <script> tags below with inlined minified JS
  - Replace __GAME_CONFIG__ with the actual JSON config object
  - Target build size: under 5MB total
-->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.2/dist/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-filters@5.3.1/dist/browser/pixi-filters.js"></script>

<script>
'use strict';

// ============================================================
// CONFIG
// In production: __GAME_CONFIG__ is replaced by the build pipeline.
// In engine_test.html: this is set to a real object before this script.
// ============================================================
const CONFIG = __GAME_CONFIG__;

// ============================================================
// CONSTANTS
// ============================================================
const STAGE_W = 390;
const STAGE_H = 844;
// Card dimensions - can be overridden by visual config
const CARD_W  = CONFIG.visual.card_width || 70;
const CARD_H  = CONFIG.visual.card_height || 96;
const VALS    = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const SUITS   = { H: '\u2665', D: '\u2666', C: '\u2663', S: '\u2660' };
const SPEEDS  = { slow: 600, medium: 350, fast: 180 };
const CONFETTI_COLORS = [0xffe066, 0xff6b6b, 0x6bffb8, 0x6bb8ff, 0xff6bff, 0xffffff];

// ============================================================
// HELPERS
// ============================================================
function parseCard(code) {
  const suit  = code.slice(-1);
  const value = code.slice(0, -1);
  return { code, value, suit, symbol: SUITS[suit], isRed: suit === 'H' || suit === 'D' };
}

function isValidMove(cardCode, foundationCode) {
  const ci = VALS.indexOf(parseCard(cardCode).value);
  const fi = VALS.indexOf(parseCard(foundationCode).value);
  return (ci + 1) % 13 === fi || (fi + 1) % 13 === ci;
}

function hex(str) { return parseInt(str.replace('#', ''), 16); }
function rand(min, max) { return min + Math.random() * (max - min); }

// ============================================================
// EASING
// ============================================================
const Ease = {
  linear:    t => t,
  easeOut:   t => 1 - Math.pow(1 - t, 3),
  easeIn:    t => t * t * t,
  easeInOut: t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2,
  spring:    t => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return Math.pow(2, -10*t) * Math.sin((t*10 - 0.75) * (2*Math.PI/3)) + 1;
  },
  bounce: t => {
    const n1 = 7.5625, d1 = 2.75;
    if      (t < 1/d1)    return n1*t*t;
    else if (t < 2/d1)  { t -= 1.5/d1;   return n1*t*t + 0.75; }
    else if (t < 2.5/d1){ t -= 2.25/d1;  return n1*t*t + 0.9375; }
    else                  { t -= 2.625/d1; return n1*t*t + 0.984375; }
  }
};

// ============================================================
// PIXI APPLICATION
// ============================================================
const app = new PIXI.Application({
  width:           STAGE_W,
  height:          STAGE_H,
  antialias:       true,
  resolution:      Math.min(window.devicePixelRatio || 1, 2),
  autoDensity:     true,
  backgroundColor: 0x000000,
  preserveDrawingBuffer: true,  // Enables canvas screenshot capture
});
document.body.appendChild(app.view);

function resize() {
  const W = window.innerWidth, H = window.innerHeight;
  const scale = Math.min(W / STAGE_W, H / STAGE_H);
  const cw = Math.round(STAGE_W * scale), ch = Math.round(STAGE_H * scale);
  app.view.style.width    = cw + 'px';
  app.view.style.height   = ch + 'px';
  app.view.style.position = 'absolute';
  app.view.style.left     = Math.round((W - cw) / 2) + 'px';
  app.view.style.top      = Math.round((H - ch) / 2) + 'px';
}
resize();
window.addEventListener('resize', resize);

// ============================================================
// TWEEN SYSTEM
// ============================================================
const tweens = [];

function tween(obj, props, duration, ease, onDone) {
  const start = {};
  for (const k in props) start[k] = obj[k];
  tweens.push({ obj, start, props, duration, ease: ease || Ease.easeOut, elapsed: 0, done: false, onDone });
}

function updateTweens() {
  const dt = app.ticker.deltaMS;
  for (let i = tweens.length - 1; i >= 0; i--) {
    const tw = tweens[i];
    if (tw.done) { tweens.splice(i, 1); continue; }
    tw.elapsed += dt;
    const t = Math.min(tw.elapsed / tw.duration, 1);
    const e = tw.ease(t);
    for (const k in tw.props) tw.obj[k] = tw.start[k] + (tw.props[k] - tw.start[k]) * e;
    if (t >= 1) { tw.done = true; if (tw.onDone) tw.onDone(); }
  }
}

function delay(ms, cb) {
  let elapsed = 0;
  const tick = () => { elapsed += app.ticker.deltaMS; if (elapsed >= ms) { app.ticker.remove(tick); cb(); } };
  app.ticker.add(tick);
}

function killTweensOf(obj) {
  for (let i = tweens.length - 1; i >= 0; i--) {
    if (tweens[i].obj === obj || tweens[i].obj === obj.scale) tweens.splice(i, 1);
  }
}

// ============================================================
// SCENE GRAPH
// ============================================================
const gameContainer     = new PIXI.Container();
const bgLayer           = new PIXI.Graphics();
const tableauContainer  = new PIXI.Container();
const foundationLayer   = new PIXI.Container();
const drawPileContainer = new PIXI.Container();
const hudContainer      = new PIXI.Container();
const flyingCardLayer   = new PIXI.Container();
const overlayContainer  = new PIXI.Container();

app.stage.addChild(gameContainer);
gameContainer.addChild(bgLayer);
gameContainer.addChild(tableauContainer);
gameContainer.addChild(foundationLayer);
gameContainer.addChild(drawPileContainer);
gameContainer.addChild(hudContainer);
gameContainer.addChild(flyingCardLayer);
gameContainer.addChild(overlayContainer);

// ============================================================
// IMAGE ASSET SPRITES  (null = use code-drawn fallback)
// ============================================================
let _bgSprite   = null;
let _feltSprite = null;
let _cardBackTexture = null;
let _suitTextures = { H: null, D: null, C: null, S: null };

function _loadImageAssets() {
  const V = CONFIG.visual;
  if (V.card_back_image) {
    _cardBackTexture = PIXI.Texture.from('data:image/png;base64,' + V.card_back_image);
  }

  // Load suit icon PNGs (if available in config)
  if (V.suit_heart_image)   _suitTextures.H = PIXI.Texture.from('data:image/png;base64,' + V.suit_heart_image);
  if (V.suit_diamond_image) _suitTextures.D = PIXI.Texture.from('data:image/png;base64,' + V.suit_diamond_image);
  if (V.suit_club_image)    _suitTextures.C = PIXI.Texture.from('data:image/png;base64,' + V.suit_club_image);
  if (V.suit_spade_image)   _suitTextures.S = PIXI.Texture.from('data:image/png;base64,' + V.suit_spade_image);
}

// ============================================================
// BACKGROUND
// ============================================================
function drawBackground() {
  const V = CONFIG.visual;
  bgLayer.clear();

  // Remove any previous image sprites
  if (_bgSprite)   { bgLayer.removeChild(_bgSprite);   _bgSprite.destroy();   _bgSprite   = null; }
  if (_feltSprite) { bgLayer.removeChild(_feltSprite); _feltSprite.destroy(); _feltSprite = null; }

  // Background — image or solid color
  if (V.background_image) {
    const tex = PIXI.Texture.from('data:image/png;base64,' + V.background_image);
    _bgSprite = new PIXI.Sprite(tex);
    _bgSprite.width  = STAGE_W;
    _bgSprite.height = STAGE_H;
    bgLayer.addChildAt(_bgSprite, 0);
  } else {
    bgLayer.beginFill(hex(V.background_color));
    bgLayer.drawRect(0, 0, STAGE_W, STAGE_H);
    bgLayer.endFill();
  }

  // Felt / table surface — image or semi-transparent overlay
  if (V.felt_image) {
    const tex = PIXI.Texture.from('data:image/png;base64,' + V.felt_image);
    _feltSprite = new PIXI.Sprite(tex);
    _feltSprite.x      = 12;    _feltSprite.y      = 90;
    _feltSprite.width  = STAGE_W - 24;
    _feltSprite.height = STAGE_H - 190;
    bgLayer.addChild(_feltSprite);
  } else {
    bgLayer.beginFill(hex(V.table_felt_color), 0.35);
    bgLayer.drawRoundedRect(12, 90, STAGE_W - 24, STAGE_H - 190, 14);
    bgLayer.endFill();
  }
}

// ============================================================
// CARD RENDERING
// ============================================================
const PIP_POSITIONS = {
  'A':  [[.5,.5]],
  '2':  [[.5,.22],[.5,.78]],
  '3':  [[.5,.18],[.5,.5],[.5,.82]],
  '4':  [[.28,.22],[.72,.22],[.28,.78],[.72,.78]],
  '5':  [[.28,.18],[.72,.18],[.5,.5],[.28,.82],[.72,.82]],
  '6':  [[.28,.18],[.72,.18],[.28,.5],[.72,.5],[.28,.82],[.72,.82]],
  '7':  [[.28,.14],[.72,.14],[.5,.32],[.28,.5],[.72,.5],[.28,.75],[.72,.75]],
  '8':  [[.28,.12],[.72,.12],[.28,.37],[.72,.37],[.28,.63],[.72,.63],[.28,.88],[.72,.88]],
  '9':  [[.28,.1],[.72,.1],[.28,.33],[.72,.33],[.5,.5],[.28,.67],[.72,.67],[.28,.9],[.72,.9]],
  '10': [[.28,.08],[.72,.08],[.5,.22],[.28,.38],[.72,.38],[.28,.62],[.72,.62],[.5,.78],[.28,.92],[.72,.92]],
};
const PIP_X0 = 10, PIP_W = 50, PIP_Y0 = 22, PIP_H = 52;

// Helper: Create suit sprite or fallback to text
function createSuitElement(suit, size = 12) {
  const texture = _suitTextures[suit];
  if (texture) {
    // Use SVG sprite
    const sprite = new PIXI.Sprite(texture);
    sprite.width = size;
    sprite.height = size;
    sprite.anchor.set(0, 0);
    return sprite;
  } else {
    // Fallback to text symbol
    const color = (suit === 'H' || suit === 'D') ? 0xcc2222 : 0x111111;
    const text = new PIXI.Text(SUITS[suit], {
      fontFamily: 'Arial',
      fontWeight: 'bold',
      fontSize: size,
      fill: color
    });
    return text;
  }
}

function addFaceTexts(container, info) {
  const color = info.isRed ? 0xcc2222 : 0x111111;
  const base  = { fontFamily: 'Arial', fontWeight: 'bold', fill: color };

  // Top-left corner: value + suit icon
  const tlValue = new PIXI.Text(info.value, { ...base, fontSize: 11 });
  tlValue.x = 4; tlValue.y = 3;
  container.addChild(tlValue);

  const tlSuit = createSuitElement(info.suit, 11);
  tlSuit.x = 4; tlSuit.y = 16;
  container.addChild(tlSuit);

  // Bottom-right corner: value + suit icon (rotated)
  const brCont = new PIXI.Container();
  brCont.x = CARD_W; brCont.y = CARD_H; brCont.rotation = Math.PI;

  const brValue = new PIXI.Text(info.value, { ...base, fontSize: 11 });
  brValue.x = 4; brValue.y = 3;
  brCont.addChild(brValue);

  const brSuit = createSuitElement(info.suit, 11);
  brSuit.x = 4; brSuit.y = 16;
  brCont.addChild(brSuit);

  container.addChild(brCont);

  // Center pips or face letter
  if (PIP_POSITIONS[info.value]) {
    const pips = PIP_POSITIONS[info.value];
    const sz = pips.length <= 2 ? 15 : pips.length <= 4 ? 13 : pips.length <= 6 ? 12 : 10;
    for (const [nx, ny] of pips) {
      const pip = createSuitElement(info.suit, sz);
      pip.anchor.set(0.5, 0.5);
      pip.x = PIP_X0 + nx * PIP_W;
      pip.y = PIP_Y0 + ny * PIP_H;
      container.addChild(pip);
    }
  } else {
    const ltr = new PIXI.Text(info.value, { ...base, fontSize: 28 });
    ltr.anchor.set(0.5); ltr.x = CARD_W / 2; ltr.y = CARD_H / 2;
    container.addChild(ltr);
  }
}

function makeCardSprite(code, faceUp) {
  const V   = CONFIG.visual;
  const c   = new PIXI.Container();
  c.interactive = true;
  c.buttonMode  = true;

  const g = new PIXI.Graphics();
  c.addChild(g);

  if (faceUp) {
    const info = parseCard(code);
    g.beginFill(hex(V.card_face_color));
    g.lineStyle(1.5, hex(V.card_border_color));
    g.drawRoundedRect(0, 0, CARD_W, CARD_H, 6);
    g.endFill();
    addFaceTexts(c, info);
  } else {
    if (_cardBackTexture) {
      // Use image asset for card back
      const s = new PIXI.Sprite(_cardBackTexture);
      s.width  = CARD_W;
      s.height = CARD_H;
      c.addChild(s);
    } else {
      // Code-drawn fallback
      g.beginFill(hex(V.card_back_color));
      g.lineStyle(1.5, hex(V.card_border_color));
      g.drawRoundedRect(0, 0, CARD_W, CARD_H, 6);
      g.endFill();
      if (V.card_back_pattern === 'stripes') {
        g.lineStyle(1, 0xffffff, 0.15);
        for (let x = 8; x < CARD_W; x += 8) { g.moveTo(x, 0); g.lineTo(x, CARD_H); }
      } else if (V.card_back_pattern === 'dots') {
        g.lineStyle(0); g.beginFill(0xffffff, 0.15);
        for (let x = 10; x < CARD_W; x += 10)
          for (let y = 10; y < CARD_H; y += 10) g.drawCircle(x, y, 2);
        g.endFill();
      }
      g.lineStyle(1, 0xffffff, 0.2);
      g.drawRoundedRect(4, 4, CARD_W - 8, CARD_H - 8, 4);
    }
  }

  c._code   = code;
  c._faceUp = faceUp;
  return c;
}

// ============================================================
// GLOW FILTER
// ============================================================
let glowFilter = null;
let glowTime   = 0;

const floatingCards = [];
let floatTime = 0;

function initGlowFilter() {
  if (PIXI.filters && PIXI.filters.GlowFilter) {
    glowFilter = new PIXI.filters.GlowFilter({
      outerStrength: 0,
      innerStrength: 0,
      color:    hex(CONFIG.visual.highlight_color),
      distance: 14,
      quality:  0.1,
    });
  }
}

function updateGlow() {
  if (!glowFilter) return;
  glowTime += app.ticker.deltaMS * 0.004;
  glowFilter.outerStrength = 1.8 + Math.sin(glowTime) * 1.2;
}

function updateFloat() {
  if (!floatingCards.length) return;
  floatTime += app.ticker.deltaMS * 0.004;
  floatingCards.forEach(card => {
    card.sprite.y = card.targetY + Math.sin(floatTime + card._floatPhase) * 8;
  });
}

function startFloating(card) {
  card._floatPhase = Math.random() * Math.PI * 2;
  if (!floatingCards.includes(card)) floatingCards.push(card);
}

function stopAllFloating() {
  floatingCards.forEach(card => {
    tween(card.sprite, { y: card.targetY }, 120, Ease.easeOut);
  });
  floatingCards.length = 0;
}

// ============================================================
// FOUNDATION
// ============================================================
let foundationSprite = null;

function drawFoundationSlot() {
  const slot = new PIXI.Graphics();
  slot.lineStyle(2, 0xffffff, 0.25);
  slot.drawRoundedRect(0, 0, CARD_W, CARD_H, 6);
  slot.x = STAGE_W / 2 - CARD_W / 2;
  slot.y = 560;
  foundationLayer.addChild(slot);
}

function setFoundation(code) {
  if (foundationSprite) {
    foundationLayer.removeChild(foundationSprite);
    foundationSprite.destroy({ children: true });
  }
  foundationSprite = makeCardSprite(code, true);
  foundationSprite.x = STAGE_W / 2 - CARD_W / 2;
  foundationSprite.y = 560;
  foundationSprite.interactive = false;
  foundationLayer.addChild(foundationSprite);
  state.foundation = code;
}

// ============================================================
// DRAW PILE
// ============================================================
function buildDrawPile() {
  drawPileContainer.removeChildren();
  if (!state.drawPile.length) return;

  const x = 24, y = STAGE_H - CARD_H - 50;

  // Stack depth visual
  for (let i = Math.min(2, state.drawPile.length - 1); i >= 0; i--) {
    const bg = new PIXI.Graphics();
    bg.beginFill(hex(CONFIG.visual.card_back_color));
    bg.lineStyle(1, hex(CONFIG.visual.card_border_color));
    bg.drawRoundedRect(i * 2, -i * 2, CARD_W, CARD_H, 6);
    bg.endFill();
    drawPileContainer.addChild(bg);
  }

  // Top card (tappable)
  const top = makeCardSprite(state.drawPile[0], false);
  top.on('pointerdown', onDrawPileTap);
  drawPileContainer.addChild(top);

  const lbl = new PIXI.Text('DRAW', { fontFamily: 'Arial', fontSize: 10, fill: 0xffffff, alpha: 0.5 });
  lbl.anchor.set(0.5, 0);
  lbl.x = CARD_W / 2; lbl.y = CARD_H + 4;
  drawPileContainer.addChild(lbl);

  drawPileContainer.x = x;
  drawPileContainer.y = y;
}

// ============================================================
// HUD (testing mode only)
// ============================================================
function buildHUD() {
  hudContainer.removeChildren();

  const remaining = state.tableau.filter(c => !c.removed).length;
  const style = { fontFamily: 'Arial', fontSize: 13, fill: 0xffffff };

  const lvlTxt = new PIXI.Text(`Level ${state.levelIndex + 1} / ${CONFIG.levels.total_levels}`, style);
  lvlTxt.x = 16; lvlTxt.y = 18;
  hudContainer.addChild(lvlTxt);

  const cardsTxt = new PIXI.Text(`Cards left: ${remaining}`, style);
  cardsTxt.anchor.set(1, 0);
  cardsTxt.x = STAGE_W - 16; cardsTxt.y = 18;
  hudContainer.addChild(cardsTxt);

  const badge = new PIXI.Graphics();
  badge.beginFill(0xcc2200);
  badge.drawRoundedRect(0, 0, 108, 18, 4);
  badge.endFill();
  badge.x = STAGE_W / 2 - 54; badge.y = 14;
  hudContainer.addChild(badge);

  const testTxt = new PIXI.Text('TESTING MODE', { fontFamily: 'Arial', fontSize: 9, fill: 0xffffff });
  testTxt.anchor.set(0.5, 0.5);
  testTxt.x = STAGE_W / 2; testTxt.y = 23;
  hudContainer.addChild(testTxt);
}

// ============================================================
// CARD GRID POSITION
// ============================================================
function getCardPos(col, row, grid, totalCols) {
  const totalW = totalCols * grid.cell_width;
  const startX = Math.round(grid.origin_x * STAGE_W - totalW / 2);
  const startY = Math.round(grid.origin_y * STAGE_H);
  return {
    x: startX + col * grid.cell_width + (grid.cell_width - CARD_W) / 2,
    y: startY + row * grid.cell_height,
  };
}

// ============================================================
// GAME STATE
// ============================================================
const state = {
  phase:       'entering',  // entering | playing | won | failed | transitioning | end
  levelIndex:  0,
  foundation:  '',
  tableau:     [],          // { code, faceUp, col, row, sprite, targetX, targetY, removed }
  drawPile:    [],
  drawIndex:   -1,
  animating:   false,
};

// Expose game state to parent window for screenshot capture metadata
Object.defineProperty(window, 'currentLevel', { get: () => state.levelIndex });
Object.defineProperty(window, 'foundation', { get: () => state.foundation });
Object.defineProperty(window, 'tableau', { get: () => state.tableau });
Object.defineProperty(window, 'drawPile', { get: () => state.drawPile });

// ============================================================
// BUILD LEVEL
// ============================================================
const PEEK = 14; // px of face-down card visible below the face-up card above it

function buildLevel(index) {
  const lvl  = CONFIG.levels.levels[index];
  const grid = lvl.layout.grid;

  tableauContainer.removeChildren();
  drawPileContainer.removeChildren();
  flyingCardLayer.removeChildren();
  foundationLayer.removeChildren();

  state.tableau   = [];
  state.drawPile  = [...lvl.layout.draw_pile];
  state.drawIndex = -1;
  state.animating = true;
  state.phase     = 'entering';
  state.levelIndex = index;

  drawFoundationSlot();
  setFoundation(lvl.layout.foundation_card);

  const totalCols = Math.max(...lvl.layout.tableau.map(c => c.col)) + 1;

  const gridPos = {};
  for (const cd of lvl.layout.tableau)
    gridPos[`${cd.col},${cd.row}`] = getCardPos(cd.col, cd.row, grid, totalCols);

  const byCol = {};
  for (const cd of lvl.layout.tableau) {
    if (!byCol[cd.col]) byCol[cd.col] = { up: [], down: [] };
    (cd.face_up ? byCol[cd.col].up : byCol[cd.col].down).push(cd);
  }

  const addCard = (cd, displayX, displayY, targetX, targetY) => {
    const sprite = makeCardSprite(cd.code, cd.face_up);
    sprite.alpha = 0; sprite.x = displayX; sprite.y = displayY;
    const card = { code: cd.code, faceUp: cd.face_up, col: cd.col, row: cd.row,
                   sprite, displayX, displayY, targetX, targetY, removed: false };
    sprite.on('pointerdown', () => onCardTap(card));
    tableauContainer.addChild(sprite);
    state.tableau.push(card);
  };

  // Face-down cards added first (renders behind face-up cards)
  for (const col in byCol) {
    const { up, down } = byCol[col];
    if (!down.length) continue;
    const bottomUp = up.sort((a, b) => b.row - a.row)[0];
    if (!bottomUp) continue;
    const anchor = gridPos[`${bottomUp.col},${bottomUp.row}`];
    [...down].reverse().forEach((cd, i) => {
      const peekIdx = down.length - 1 - i;
      addCard(cd, anchor.x, anchor.y + PEEK * (peekIdx + 1), anchor.x, anchor.y);
    });
  }

  // Face-up cards added after (renders in front)
  for (const cd of lvl.layout.tableau) {
    if (!cd.face_up) continue;
    const pos = gridPos[`${cd.col},${cd.row}`];
    addCard(cd, pos.x, pos.y, pos.x, pos.y);
  }

  if (lvl.show_draw_pile && state.drawPile.length > 0) buildDrawPile();
  if (CONFIG.levels.testing_mode) buildHUD();

  runEnterAnimation(lvl);
}

// ============================================================
// ENTER ANIMATIONS
// ============================================================
function runEnterAnimation(lvl) {
  const type     = lvl.enter_animation;
  const duration = lvl.enter_duration_ms;

  const cards   = [...state.tableau].sort((a, b) => b.displayY - a.displayY);
  const stagger = Math.min((duration * 0.6) / cards.length, 160);
  const flyDur  = Math.max(duration * 0.5, 280);

  let pending = cards.length;
  const onAllDone = () => {
    state.phase    = 'playing';
    state.animating = false;
    highlightValidMoves();
  };

  if (type === 'shuffle_in') {
    cards.forEach((card, i) => {
      delay(i * stagger, () => {
        const angle = rand(0, Math.PI * 2);
        card.sprite.x     = card.displayX + Math.cos(angle) * 700;
        card.sprite.y     = card.displayY + Math.sin(angle) * 700;
        card.sprite.alpha = 1;
        tween(card.sprite, { x: card.displayX, y: card.displayY }, flyDur, Ease.easeOut, () => {
          pending--; if (pending === 0) onAllDone();
        });
      });
    });

  } else if (type === 'drop_down') {
    cards.forEach((card, i) => {
      card.sprite.x     = card.displayX;
      card.sprite.y     = card.displayY - STAGE_H - 80;
      card.sprite.alpha = 1;
      delay(i * stagger, () => {
        tween(card.sprite, { y: card.displayY }, flyDur, Ease.bounce, () => {
          pending--; if (pending === 0) onAllDone();
        });
      });
    });

  } else if (type === 'bulk') {
    cards.forEach(card => {
      card.sprite.y    -= 180;
      card.sprite.alpha = 1;
    });
    cards.forEach(card => {
      tween(card.sprite, { y: card.displayY }, duration, Ease.spring, () => {
        pending--; if (pending === 0) onAllDone();
      });
    });

  } else {
    // instant fallback
    cards.forEach(card => { card.sprite.alpha = 1; });
    onAllDone();
  }
}

// ============================================================
// HIGHLIGHTS
// ============================================================
function highlightValidMoves() {
  stopAllFloating();
  if (!CONFIG.mechanics.highlight_valid_moves) return;
  state.tableau.forEach(card => {
    if (card.removed || !card.faceUp) { card.sprite.filters = []; return; }
    const valid = isValidMove(card.code, state.foundation);
    card.sprite.filters = (valid && glowFilter) ? [glowFilter] : [];
    if (valid) startFloating(card);
  });
}

function clearHighlights() {
  state.tableau.forEach(c => { if (c.sprite) c.sprite.filters = []; });
  stopAllFloating();
}

// ============================================================
// TAP HANDLERS
// ============================================================
function onCardTap(card) {
  if (state.phase !== 'playing' || state.animating) return;
  if (card.removed || !card.faceUp) return;
  if (!isValidMove(card.code, state.foundation)) return;
  state.animating = true;
  clearHighlights();
  flyCardToFoundation(card);
}

function onDrawPileTap() {
  if (state.phase !== 'playing' || state.animating) return;
  if (!state.drawPile.length) return;
  state.drawIndex = (state.drawIndex + 1) % state.drawPile.length;
  const code = state.drawPile[state.drawIndex];
  clearHighlights();
  tween(foundationSprite, { alpha: 0 }, 120, Ease.linear, () => {
    setFoundation(code);
    foundationSprite.alpha = 0;
    tween(foundationSprite, { alpha: 1 }, 120, Ease.linear, highlightValidMoves);
  });
}

// ============================================================
// CARD FLIGHT
// ============================================================
function flyCardToFoundation(card) {
  const speed    = SPEEDS[CONFIG.mechanics.card_move_speed] || 350;
  const animType = CONFIG.mechanics.animation_type;
  const destX    = STAGE_W / 2 - CARD_W / 2;
  const destY    = 560;

  // Move to flying layer (renders on top)
  const wPos = card.sprite.getGlobalPosition();
  tableauContainer.removeChild(card.sprite);
  flyingCardLayer.addChild(card.sprite);
  card.sprite.x = wPos.x;
  card.sprite.y = wPos.y;
  card.removed  = true;

  const land = () => onCardLanded(card);

  if (animType === 'instant') {
    card.sprite.x = destX; card.sprite.y = destY;
    land(); return;
  }

  if (animType === 'flip') {
    tween(card.sprite, { x: destX, y: destY }, speed * 0.55, Ease.easeIn, () => {
      tween(card.sprite.scale, { x: 0 }, speed * 0.12, Ease.easeIn, () => {
        tween(card.sprite.scale, { x: 1 }, speed * 0.12, Ease.easeOut, () => {
          tween(card.sprite.scale, { y: 0.88 }, speed * 0.1, Ease.easeIn, () => {
            tween(card.sprite.scale, { y: 1 }, speed * 0.2, Ease.spring, land);
          });
        });
      });
    });
  } else {
    // slide
    tween(card.sprite, { x: destX, y: destY }, speed, Ease.easeOut, () => {
      tween(card.sprite.scale, { x: 1.08, y: 0.92 }, speed * 0.1, Ease.easeIn, () => {
        tween(card.sprite.scale, { x: 1, y: 1 }, speed * 0.18, Ease.spring, land);
      });
    });
  }
}

function onCardLanded(card) {
  flyingCardLayer.removeChild(card.sprite);
  setFoundation(card.code);
  revealNextCard(card.col);
  if (CONFIG.levels.testing_mode) buildHUD();
  checkGameState();
}

// ============================================================
// CARD REVEAL
// ============================================================
function revealNextCard(col) {
  const candidates = state.tableau
    .filter(c => !c.removed && !c.faceUp && c.col === col)
    .sort((a, b) => a.row - b.row);
  if (!candidates.length) return;
  flipFaceUp(candidates[0]);
}

function flipFaceUp(card) {
  card.faceUp = true;
  const doFlip = () => {
    tween(card.sprite.scale, { x: 0 }, 130, Ease.easeIn, () => {
      const ns = makeCardSprite(card.code, true);
      ns.x = card.sprite.x; ns.y = card.sprite.y; ns.scale.x = 0;
      ns.on('pointerdown', () => onCardTap(card));
      tableauContainer.removeChild(card.sprite);
      card.sprite.destroy({ children: true });
      card.sprite = ns;
      tableauContainer.addChild(ns);
      tween(ns.scale, { x: 1 }, 130, Ease.easeOut);
    });
  };
  // If card is at peek position, slide up to target first
  if (Math.abs(card.sprite.y - card.targetY) > 2) {
    tween(card.sprite, { x: card.targetX, y: card.targetY }, 180, Ease.easeOut, doFlip);
  } else {
    doFlip();
  }
}

// ============================================================
// GAME STATE CHECK
// ============================================================
function checkGameState() {
  const remaining = state.tableau.filter(c => !c.removed);
  if (!remaining.length) { delay(300, triggerWin); return; }

  const hasMove = remaining
    .filter(c => c.faceUp)
    .some(c => isValidMove(c.code, state.foundation));

  if (!hasMove && !state.drawPile.length) { delay(400, triggerFail); return; }

  state.animating = false;
  highlightValidMoves();
}

// ============================================================
// WIN / FAIL
// ============================================================
function triggerWin() {
  state.phase = 'won';
  clearHighlights();
  spawnConfetti();

  const lvl     = CONFIG.levels.levels[state.levelIndex];
  const isLast  = state.levelIndex >= CONFIG.levels.total_levels - 1;

  showWinOverlay(isLast);
  delay(lvl.timings.win_screen_duration_ms, () => {
    clearOverlay();
    isLast ? openCTA() : loadNextLevel();
  });
}

function triggerFail() {
  state.phase = 'failed';
  clearHighlights();
  shakeScreen(600, 8);

  const lvl = CONFIG.levels.levels[state.levelIndex];
  showFailOverlay();
  delay(lvl.timings.fail_screen_duration_ms, () => {
    clearOverlay();
    triggerEndCard();
  });
}

function loadNextLevel() {
  state.phase    = 'transitioning';
  state.animating = true;
  const dur = CONFIG.levels.levels[state.levelIndex].timings.level_transition_duration_ms;

  tween(tableauContainer, { alpha: 0 }, dur * 0.4, Ease.easeIn, () => {
    tableauContainer.alpha = 1;
    buildLevel(state.levelIndex + 1);
  });
}

// ============================================================
// CONFETTI
// ============================================================
const confetti = [];

function spawnConfetti() {
  for (let i = 0; i < 65; i++) {
    const g = new PIXI.Graphics();
    const color = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
    g.beginFill(color);
    const w = rand(4, 10), h = rand(4, 10);
    g.drawRect(0, 0, w, h);
    g.endFill();
    g.x        = STAGE_W / 2 + rand(-70, 70);
    g.y        = 560 + rand(-20, 20);
    g.rotation = rand(0, Math.PI * 2);
    g._vx      = rand(-5, 5);
    g._vy      = rand(-14, -5);
    g._vr      = rand(-0.2, 0.2);
    g._grav    = rand(0.25, 0.45);
    overlayContainer.addChild(g);
    confetti.push(g);
  }
}

function updateConfetti() {
  for (let i = confetti.length - 1; i >= 0; i--) {
    const p = confetti[i];
    p._vy += p._grav;
    p.x += p._vx; p.y += p._vy; p.rotation += p._vr;
    if (p.y > STAGE_H + 60) { overlayContainer.removeChild(p); confetti.splice(i, 1); }
  }
}

// ============================================================
// SCREEN SHAKE
// ============================================================
function shakeScreen(duration, intensity) {
  let elapsed = 0;
  const tick = () => {
    elapsed += app.ticker.deltaMS;
    if (elapsed >= duration) { gameContainer.x = 0; gameContainer.y = 0; app.ticker.remove(tick); return; }
    const amt = intensity * (1 - elapsed / duration);
    gameContainer.x = (Math.random() * 2 - 1) * amt;
    gameContainer.y = (Math.random() * 2 - 1) * amt;
  };
  app.ticker.add(tick);
}

// ============================================================
// OVERLAYS
// ============================================================
function clearOverlay() {
  overlayContainer.removeChildren();
  confetti.length = 0;
}

function makePanel(yCenter, bgFill, borderColor) {
  const o = new PIXI.Container();
  const dim = new PIXI.Graphics();
  dim.beginFill(0x000000, 0.55); dim.drawRect(0, 0, STAGE_W, STAGE_H); dim.endFill();
  o.addChild(dim);
  const panel = new PIXI.Graphics();
  panel.beginFill(bgFill); panel.lineStyle(2, borderColor, 0.5);
  panel.drawRoundedRect(STAGE_W / 2 - 150, yCenter - 110, 300, 220, 18);
  panel.endFill();
  o.addChild(panel);
  return o;
}

function showWinOverlay(isLast) {
  const o = makePanel(STAGE_H / 2, hex(CONFIG.visual.table_felt_color), 0xffffff);

  const title = new PIXI.Text(isLast ? 'You Win!' : 'Level Clear!', {
    fontFamily: 'Arial', fontSize: 38, fontWeight: 'bold', fill: 0xffffff, align: 'center'
  });
  title.anchor.set(0.5); title.x = STAGE_W / 2; title.y = STAGE_H / 2 - 40;
  o.addChild(title);

  const sub = new PIXI.Text(isLast ? 'All levels cleared!' : 'Get ready for the next level...', {
    fontFamily: 'Arial', fontSize: 17, fill: 0xffffff, align: 'center'
  });
  sub.anchor.set(0.5); sub.x = STAGE_W / 2; sub.y = STAGE_H / 2 + 20;
  o.addChild(sub);

  o.alpha = 0;
  tween(o, { alpha: 1 }, 300, Ease.easeOut);
  overlayContainer.addChild(o);
  o.interactive = true;
  if (isLast) o.on('pointerdown', openCTA);
}

function showFailOverlay() {
  const o = makePanel(STAGE_H / 2, 0x660000, 0xff4444);

  const title = new PIXI.Text('No More Moves', {
    fontFamily: 'Arial', fontSize: 32, fontWeight: 'bold', fill: 0xffffff, align: 'center'
  });
  title.anchor.set(0.5); title.x = STAGE_W / 2; title.y = STAGE_H / 2 - 40;
  o.addChild(title);

  const sub = new PIXI.Text('Try the full game!', {
    fontFamily: 'Arial', fontSize: 18, fill: 0xffffff, align: 'center'
  });
  sub.anchor.set(0.5); sub.x = STAGE_W / 2; sub.y = STAGE_H / 2 + 20;
  o.addChild(sub);

  o.alpha = 0;
  tween(o, { alpha: 1 }, 300, Ease.easeOut);
  overlayContainer.addChild(o);
  o.interactive = true;
  o.on('pointerdown', openCTA);
}

function triggerEndCard() {
  state.phase = 'end';
  clearOverlay();

  const o = new PIXI.Container();
  const bg = new PIXI.Graphics();
  bg.beginFill(hex(CONFIG.visual.background_color));
  bg.drawRect(0, 0, STAGE_W, STAGE_H);
  bg.endFill();
  o.addChild(bg);

  const headline = new PIXI.Text('Play the full game!', {
    fontFamily: 'Arial', fontSize: 30, fontWeight: 'bold',
    fill: hex(CONFIG.visual.primary_text_color), align: 'center', wordWrap: true, wordWrapWidth: 320
  });
  headline.anchor.set(0.5); headline.x = STAGE_W / 2; headline.y = STAGE_H / 2 - 80;
  o.addChild(headline);

  const btnW = 260, btnH = 66;
  const btn = new PIXI.Graphics();
  btn.beginFill(hex(CONFIG.visual.button_color));
  btn.drawRoundedRect(0, 0, btnW, btnH, 33);
  btn.endFill();
  btn.x = STAGE_W / 2 - btnW / 2; btn.y = STAGE_H / 2 + 20;
  btn.interactive = true; btn.buttonMode = true;
  o.addChild(btn);

  const btnTxt = new PIXI.Text(CONFIG.levels.cta_text || 'Play Now!', {
    fontFamily: 'Arial', fontSize: 24, fontWeight: 'bold', fill: hex(CONFIG.visual.button_text_color)
  });
  btnTxt.anchor.set(0.5); btnTxt.x = STAGE_W / 2; btnTxt.y = STAGE_H / 2 + 20 + btnH / 2;
  o.addChild(btnTxt);

  o.alpha = 0;
  tween(o, { alpha: 1 }, 400, Ease.easeOut);
  overlayContainer.addChild(o);
  btn.on('pointerdown', openCTA);
  o.interactive = true; o.on('pointerdown', openCTA);
}

// ============================================================
// MRAID / CTA
// ============================================================
function openCTA() {
  const url = CONFIG.levels.target_url || 'https://example.com';
  if (typeof mraid !== 'undefined' && typeof mraid.open === 'function') {
    mraid.open(url);
  } else {
    window.location.href = url;
  }
}

function initMRAID() {
  if (typeof mraid !== 'undefined') {
    if (mraid.getState() === 'loading') {
      mraid.addEventListener('ready', startGame);
    } else {
      startGame();
    }
  } else {
    startGame();
  }
}

// ============================================================
// MAIN LOOP
// ============================================================
app.ticker.add(() => {
  updateTweens();
  updateGlow();
  updateFloat();
  updateConfetti();
});

// ============================================================
// START
// ============================================================
function startGame() {
  _loadImageAssets();
  drawBackground();
  initGlowFilter();
  buildLevel(0);
}

initMRAID();
</script>
</body>
</html>
